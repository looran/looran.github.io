{"version":3,"file":"index.js","sources":["../../wgsl-debug/example/vite/modulepreload-polyfill","../../wgsl-debug/dist/wgsl-debug.es.js","../../wgsl-debug/wgsl-debug-table/dist/wgsl-debug-table.es.js","../../wgsl-debug/example/main.ts"],"sourcesContent":["const p = function polyfill() {\n    const relList = document.createElement('link').relList;\n    if (relList && relList.supports && relList.supports('modulepreload')) {\n        return;\n    }\n    for (const link of document.querySelectorAll('link[rel=\"modulepreload\"]')) {\n        processPreload(link);\n    }\n    new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            if (mutation.type !== 'childList') {\n                continue;\n            }\n            for (const node of mutation.addedNodes) {\n                if (node.tagName === 'LINK' && node.rel === 'modulepreload')\n                    processPreload(node);\n            }\n        }\n    }).observe(document, { childList: true, subtree: true });\n    function getFetchOpts(script) {\n        const fetchOpts = {};\n        if (script.integrity)\n            fetchOpts.integrity = script.integrity;\n        if (script.referrerpolicy)\n            fetchOpts.referrerPolicy = script.referrerpolicy;\n        if (script.crossorigin === 'use-credentials')\n            fetchOpts.credentials = 'include';\n        else if (script.crossorigin === 'anonymous')\n            fetchOpts.credentials = 'omit';\n        else\n            fetchOpts.credentials = 'same-origin';\n        return fetchOpts;\n    }\n    function processPreload(link) {\n        if (link.ep)\n            // ep marker = processed\n            return;\n        link.ep = true;\n        // prepopulate the load record\n        const fetchOpts = getFetchOpts(link);\n        fetch(link.href, fetchOpts);\n    }\n};__VITE_IS_MODERN__&&p();","const _WGSL_debug = class {\n  constructor(bindgroup_num, buf_unit_entries_count) {\n    this.shader_active = () => `@group(${this.bindgroup_num}) @binding(0) var<storage,read_write> _dbg: array<u32>;\n\nvar<private> _dbg_unit: u32;\n\nfn dbg_init(uid: u32) {\n\t/* initialize debug unit for this uid */\n\t_dbg_unit = ${_WGSL_debug.BUF_HEADER_SIZE}u + uid*${this.buf_unit_size()}u;\n\t_dbg[_dbg_unit] = 0u; // entries count\n}\n\nfn dbg_32m(mark: i32, val: u32, vtype: i32) {\n\t/* limit entries count, but still store the total number of calls */\n\tvar entry_count = _dbg[_dbg_unit];\n\t_dbg[_dbg_unit] = entry_count + 1u;\n\tif (entry_count == ${this.buf_unit_entries_count}u) {\n\t\treturn;\n\t}\n\n\t/* store data in a new debug unit entry */\n\tvar entry_off = _dbg_unit + 1u + entry_count * ${_WGSL_debug.BUF_ENTRY_SIZE}u;\n\t_dbg[entry_off] = u32(vtype);\n\t_dbg[entry_off + 1u] = val;\n\t_dbg[entry_off + 2u] = u32(mark);\n}\n\nfn dbg_u32m(mark: i32, val: u32) { dbg_32m(mark, val, ${_WGSL_debug.BUF_ENTRY_TYPE_U32}); }\nfn dbg_i32m(mark: i32, val: i32) { dbg_32m(mark, bitcast<u32>(val), ${_WGSL_debug.BUF_ENTRY_TYPE_I32}); }\nfn dbg_f32m(mark: i32, val: f32) { dbg_32m(mark, bitcast<u32>(val), ${_WGSL_debug.BUF_ENTRY_TYPE_F32}); }\nfn dbg_32(val: u32, vtype: i32) { dbg_32m(${_WGSL_debug.BUF_ENTRY_MARK_UNSET}, val, vtype); }\nfn dbg_u32(val: u32) { dbg_u32m(${_WGSL_debug.BUF_ENTRY_MARK_UNSET}, val); }\nfn dbg_i32(val: i32) { dbg_i32m(${_WGSL_debug.BUF_ENTRY_MARK_UNSET}, val); }\nfn dbg_f32(val: f32) { dbg_f32m(${_WGSL_debug.BUF_ENTRY_MARK_UNSET}, val); }`;\n    this.buf_unit_size = () => _WGSL_debug.BUF_UNIT_HEADER_SIZE + this.buf_unit_entries_count * _WGSL_debug.BUF_ENTRY_SIZE;\n    this.buf_unit_size_bytes = () => Uint32Array.BYTES_PER_ELEMENT * this.buf_unit_size();\n    this.bindgroup_num = bindgroup_num;\n    this.buf_unit_entries_count = buf_unit_entries_count === void 0 ? _WGSL_debug.BUF_UNIT_ENTRIES_COUNT_DEFAULT : buf_unit_entries_count;\n    this.record = new Array();\n    this.pass_n = 0;\n  }\n  set_output(output) {\n    output.attach(this);\n    this.output = output;\n  }\n  add_shader(src, active) {\n    if (active) {\n      if (src.search(/^[ \\t]*dbg_init/m) < 0) {\n        alert(\"your shader does not contain any dbg_init() call, debug will not work properly\");\n      }\n    }\n    var debug_src = active ? this.shader_active() : _WGSL_debug.SHADER_INACTIVE;\n    this.marks = new Array();\n    const dbgm_calls = src.matchAll(/^[ \\t]*dbg_[uif]?32m[ \\t]*\\([ \\t]*(?<value>[0-9]+)[^;]*;[ \\t]*(\\/\\/|\\/\\*)(?<comment>.*)/mg);\n    for (const call of dbgm_calls) {\n      const value = Number(call.groups[\"value\"]);\n      const comment = call.groups[\"comment\"].trim();\n      this.marks[value] = comment;\n    }\n    console.log(`WGSL_debug add_shader ${JSON.stringify(this.marks)}`);\n    return debug_src + \"\\n\" + src;\n  }\n  setup(device, unit_count) {\n    console.log(\"WGSL_debug setup\");\n    this.device = device;\n    this.unit_count = unit_count;\n    this.buf_size = _WGSL_debug.BUF_HEADER_SIZE_BYTES + unit_count * this.buf_unit_size_bytes();\n    console.log(`WGSL_debug unit_count=${unit_count} buf_size=${this.buf_size}`);\n    if (this.buf) {\n      this.buf.destroy();\n    }\n    this.buf = device.createBuffer({\n      size: this.buf_size,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n    });\n    if (this.dstbuf) {\n      this.dstbuf.destroy();\n    }\n    this.dstbuf = device.createBuffer({\n      size: this.buf_size,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n    });\n    this.record = new Array();\n    this.pass_n = 0;\n    if (this.output) {\n      this.output.reset();\n    } else {\n      console.log(`WGSL_debug output format: <debug_header>\n<global_invoke_id> <debug_call_n> [<record_count>] <pass_last-${this.buf_unit_entries_count}...last>`);\n    }\n  }\n  create_bindgroup(pipeline) {\n    this.bindgroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(this.bindgroup_num),\n      entries: [{ binding: 0, resource: { buffer: this.buf } }]\n    });\n  }\n  set_bindgroup(pass) {\n    pass.setBindGroup(this.bindgroup_num, this.bindgroup);\n  }\n  fetch(cmd) {\n    cmd.copyBufferToBuffer(this.buf, 0, this.dstbuf, 0, this.buf_size);\n  }\n  async process(cb_data) {\n    await this.dstbuf.mapAsync(GPUMapMode.READ);\n    const buf = this.dstbuf.getMappedRange();\n    const buf_u32 = new Uint32Array(buf);\n    const buf_i32 = new Int32Array(buf);\n    const buf_f32 = new Float32Array(buf);\n    var pass_data;\n    this.hang_detect(\"reset\");\n    pass_data = Array.from(Array(this.unit_count), () => new Array());\n    for (var uid = 0; uid < this.unit_count; uid += 1) {\n      if (this.hang_detect(\"process\")) {\n        break;\n      }\n      const unit_off = _WGSL_debug.BUF_HEADER_SIZE + uid * this.buf_unit_size();\n      const entry_count = buf_u32[unit_off];\n      if (entry_count > 0) {\n        if (entry_count > this.buf_unit_entries_count) {\n          console.warn(`WGSL debug: ${entry_count} debug calls where made from unit_id=${uid}, but only the first ${this.buf_unit_entries_count} where recorded\nConsider increasing buf_unit_entries_count.`);\n        }\n        for (var entry = 0; entry < Math.min(entry_count, this.buf_unit_entries_count); entry++) {\n          const entry_off = unit_off + _WGSL_debug.BUF_UNIT_HEADER_SIZE + entry * _WGSL_debug.BUF_ENTRY_SIZE;\n          const type = buf_u32[entry_off];\n          var value = -1;\n          if (type == _WGSL_debug.BUF_ENTRY_TYPE_U32) {\n            value = buf_u32[entry_off + 1];\n          } else if (type == _WGSL_debug.BUF_ENTRY_TYPE_I32) {\n            value = buf_i32[entry_off + 1];\n          } else if (type == _WGSL_debug.BUF_ENTRY_TYPE_F32) {\n            value = buf_f32[entry_off + 1];\n          }\n          var mark = buf_u32[entry_off + 2];\n          pass_data[uid].push({\n            value,\n            type,\n            mark\n          });\n        }\n      }\n    }\n    this.record.push(pass_data);\n    var console_log = true;\n    if (this.output) {\n      console_log = false;\n      this.output.update();\n    }\n    if (cb_data) {\n      console_log = cb_data(this.pass_n, pass_data, this.record);\n    }\n    if (console_log) {\n      console.log(`WGSL_debug ${buf_u32.slice(0, _WGSL_debug.BUF_HEADER_SIZE).toString()}`);\n      var s = \"\";\n      pass_data.forEach((entries, uid2) => {\n        s += `${uid2} [${entries.length}] ${entries}\n`;\n      });\n      console.log(s);\n    }\n    this.dstbuf.unmap();\n    this.pass_n++;\n  }\n  clear_processed() {\n    this.record.forEach((pass) => {\n      pass.forEach((entries) => {\n        entries.forEach((entry) => {\n          entry.processed = false;\n        });\n      });\n    });\n  }\n  hang_detect(current_op, resolution) {\n    if (current_op != this.hang_detect_op) {\n      this.hang_detect_op = current_op;\n      this.hang_detect_start = Date.now();\n      this.hang_detect_counter = 0;\n      this.hang_detect_resolution = resolution ? resolution : _WGSL_debug.HANG_DETECT_RESOLUTION;\n    } else {\n      this.hang_detect_counter++;\n      if (this.hang_detect_counter % this.hang_detect_resolution == 0) {\n        const now = Date.now();\n        if (now - this.hang_detect_start > _WGSL_debug.HANG_DETECT_LIMIT) {\n          console.warn(`WGSL_debug hang detected in '${current_op}' after ${this.hang_detect_counter} iterations (${_WGSL_debug.HANG_DETECT_LIMIT}ms), interrupting operation`);\n          this.hang_detect_op = null;\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n};\nlet WGSL_debug = _WGSL_debug;\nWGSL_debug.BUF_HEADER_SIZE = 16;\nWGSL_debug.BUF_HEADER_SIZE_BYTES = Uint32Array.BYTES_PER_ELEMENT * _WGSL_debug.BUF_HEADER_SIZE;\nWGSL_debug.BUF_UNIT_HEADER_SIZE = 1;\nWGSL_debug.BUF_UNIT_ENTRIES_COUNT_DEFAULT = 20;\nWGSL_debug.BUF_ENTRY_SIZE = 3;\nWGSL_debug.BUF_ENTRY_TYPE_U32 = 1;\nWGSL_debug.BUF_ENTRY_TYPE_I32 = 2;\nWGSL_debug.BUF_ENTRY_TYPE_F32 = 3;\nWGSL_debug.BUF_ENTRY_MARK_UNSET = 999999;\nWGSL_debug.HANG_DETECT_LIMIT = 500;\nWGSL_debug.HANG_DETECT_RESOLUTION = 100;\nWGSL_debug.SHADER_INACTIVE = `fn dbg_init(unit_id: u32) {}\n\nfn dbg_u32(val: u32) {}\nfn dbg_i32(val: i32) {}\nfn dbg_f32(val: f32) {}\nfn dbg_32(val: u32, vtype: u32) {}\n\nfn dbg_u32m(mark: i32, val: u32) {}\nfn dbg_i32m(mark: i32, val: i32) {}\nfn dbg_f32m(mark: i32, val: f32) {}\nfn dbg_32m(mark: i32, val: f32, vtype: i32) {}`;\nclass WGSL_debug_output {\n  constructor() {\n  }\n  attach(debug) {\n    console.log(\"WGSL_debug output attach\");\n    this.debug = debug;\n  }\n}\nexport { WGSL_debug, WGSL_debug_output };\n//# sourceMappingURL=wgsl-debug.es.js.map\n","const _WGSL_debug = class {\n  constructor(bindgroup_num, buf_unit_entries_count) {\n    this.shader_active = () => `@group(${this.bindgroup_num}) @binding(0) var<storage,read_write> _dbg: array<u32>;\n\nvar<private> _dbg_unit: u32;\n\nfn dbg_init(uid: u32) {\n\t/* initialize debug unit for this uid */\n\t_dbg_unit = ${_WGSL_debug.BUF_HEADER_SIZE}u + uid*${this.buf_unit_size()}u;\n\t_dbg[_dbg_unit] = 0u; // entries count\n}\n\nfn dbg_32m(mark: i32, val: u32, vtype: i32) {\n\t/* limit entries count, but still store the total number of calls */\n\tvar entry_count = _dbg[_dbg_unit];\n\t_dbg[_dbg_unit] = entry_count + 1u;\n\tif (entry_count == ${this.buf_unit_entries_count}u) {\n\t\treturn;\n\t}\n\n\t/* store data in a new debug unit entry */\n\tvar entry_off = _dbg_unit + 1u + entry_count * ${_WGSL_debug.BUF_ENTRY_SIZE}u;\n\t_dbg[entry_off] = u32(vtype);\n\t_dbg[entry_off + 1u] = val;\n\t_dbg[entry_off + 2u] = u32(mark);\n}\n\nfn dbg_u32m(mark: i32, val: u32) { dbg_32m(mark, val, ${_WGSL_debug.BUF_ENTRY_TYPE_U32}); }\nfn dbg_i32m(mark: i32, val: i32) { dbg_32m(mark, bitcast<u32>(val), ${_WGSL_debug.BUF_ENTRY_TYPE_I32}); }\nfn dbg_f32m(mark: i32, val: f32) { dbg_32m(mark, bitcast<u32>(val), ${_WGSL_debug.BUF_ENTRY_TYPE_F32}); }\nfn dbg_32(val: u32, vtype: i32) { dbg_32m(${_WGSL_debug.BUF_ENTRY_MARK_UNSET}, val, vtype); }\nfn dbg_u32(val: u32) { dbg_u32m(${_WGSL_debug.BUF_ENTRY_MARK_UNSET}, val); }\nfn dbg_i32(val: i32) { dbg_i32m(${_WGSL_debug.BUF_ENTRY_MARK_UNSET}, val); }\nfn dbg_f32(val: f32) { dbg_f32m(${_WGSL_debug.BUF_ENTRY_MARK_UNSET}, val); }`;\n    this.buf_unit_size = () => _WGSL_debug.BUF_UNIT_HEADER_SIZE + this.buf_unit_entries_count * _WGSL_debug.BUF_ENTRY_SIZE;\n    this.buf_unit_size_bytes = () => Uint32Array.BYTES_PER_ELEMENT * this.buf_unit_size();\n    this.bindgroup_num = bindgroup_num;\n    this.buf_unit_entries_count = buf_unit_entries_count === void 0 ? _WGSL_debug.BUF_UNIT_ENTRIES_COUNT_DEFAULT : buf_unit_entries_count;\n    this.record = new Array();\n    this.pass_n = 0;\n  }\n  set_output(output) {\n    output.attach(this);\n    this.output = output;\n  }\n  add_shader(src, active) {\n    if (active) {\n      if (src.search(/^[ \\t]*dbg_init/m) < 0) {\n        alert(\"your shader does not contain any dbg_init() call, debug will not work properly\");\n      }\n    }\n    var debug_src = active ? this.shader_active() : _WGSL_debug.SHADER_INACTIVE;\n    this.marks = new Array();\n    const dbgm_calls = src.matchAll(/^[ \\t]*dbg_[uif]?32m[ \\t]*\\([ \\t]*(?<value>[0-9]+)[^;]*;[ \\t]*(\\/\\/|\\/\\*)(?<comment>.*)/mg);\n    for (const call of dbgm_calls) {\n      const value = Number(call.groups[\"value\"]);\n      const comment = call.groups[\"comment\"].trim();\n      this.marks[value] = comment;\n    }\n    console.log(`WGSL_debug add_shader ${JSON.stringify(this.marks)}`);\n    return debug_src + \"\\n\" + src;\n  }\n  setup(device, unit_count) {\n    console.log(\"WGSL_debug setup\");\n    this.device = device;\n    this.unit_count = unit_count;\n    this.buf_size = _WGSL_debug.BUF_HEADER_SIZE_BYTES + unit_count * this.buf_unit_size_bytes();\n    console.log(`WGSL_debug unit_count=${unit_count} buf_size=${this.buf_size}`);\n    if (this.buf) {\n      this.buf.destroy();\n    }\n    this.buf = device.createBuffer({\n      size: this.buf_size,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n    });\n    if (this.dstbuf) {\n      this.dstbuf.destroy();\n    }\n    this.dstbuf = device.createBuffer({\n      size: this.buf_size,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n    });\n    this.record = new Array();\n    this.pass_n = 0;\n    if (this.output) {\n      this.output.reset();\n    } else {\n      console.log(`WGSL_debug output format: <debug_header>\n<global_invoke_id> <debug_call_n> [<record_count>] <pass_last-${this.buf_unit_entries_count}...last>`);\n    }\n  }\n  create_bindgroup(pipeline) {\n    this.bindgroup = this.device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(this.bindgroup_num),\n      entries: [{ binding: 0, resource: { buffer: this.buf } }]\n    });\n  }\n  set_bindgroup(pass) {\n    pass.setBindGroup(this.bindgroup_num, this.bindgroup);\n  }\n  fetch(cmd) {\n    cmd.copyBufferToBuffer(this.buf, 0, this.dstbuf, 0, this.buf_size);\n  }\n  async process(cb_data) {\n    await this.dstbuf.mapAsync(GPUMapMode.READ);\n    const buf = this.dstbuf.getMappedRange();\n    const buf_u32 = new Uint32Array(buf);\n    const buf_i32 = new Int32Array(buf);\n    const buf_f32 = new Float32Array(buf);\n    var pass_data;\n    this.hang_detect(\"reset\");\n    pass_data = Array.from(Array(this.unit_count), () => new Array());\n    for (var uid = 0; uid < this.unit_count; uid += 1) {\n      if (this.hang_detect(\"process\")) {\n        break;\n      }\n      const unit_off = _WGSL_debug.BUF_HEADER_SIZE + uid * this.buf_unit_size();\n      const entry_count = buf_u32[unit_off];\n      if (entry_count > 0) {\n        if (entry_count > this.buf_unit_entries_count) {\n          console.warn(`WGSL debug: ${entry_count} debug calls where made from unit_id=${uid}, but only the first ${this.buf_unit_entries_count} where recorded\nConsider increasing buf_unit_entries_count.`);\n        }\n        for (var entry = 0; entry < Math.min(entry_count, this.buf_unit_entries_count); entry++) {\n          const entry_off = unit_off + _WGSL_debug.BUF_UNIT_HEADER_SIZE + entry * _WGSL_debug.BUF_ENTRY_SIZE;\n          const type = buf_u32[entry_off];\n          var value = -1;\n          if (type == _WGSL_debug.BUF_ENTRY_TYPE_U32) {\n            value = buf_u32[entry_off + 1];\n          } else if (type == _WGSL_debug.BUF_ENTRY_TYPE_I32) {\n            value = buf_i32[entry_off + 1];\n          } else if (type == _WGSL_debug.BUF_ENTRY_TYPE_F32) {\n            value = buf_f32[entry_off + 1];\n          }\n          var mark = buf_u32[entry_off + 2];\n          pass_data[uid].push({\n            value,\n            type,\n            mark\n          });\n        }\n      }\n    }\n    this.record.push(pass_data);\n    var console_log = true;\n    if (this.output) {\n      console_log = false;\n      this.output.update();\n    }\n    if (cb_data) {\n      console_log = cb_data(this.pass_n, pass_data, this.record);\n    }\n    if (console_log) {\n      console.log(`WGSL_debug ${buf_u32.slice(0, _WGSL_debug.BUF_HEADER_SIZE).toString()}`);\n      var s = \"\";\n      pass_data.forEach((entries, uid2) => {\n        s += `${uid2} [${entries.length}] ${entries}\n`;\n      });\n      console.log(s);\n    }\n    this.dstbuf.unmap();\n    this.pass_n++;\n  }\n  clear_processed() {\n    this.record.forEach((pass) => {\n      pass.forEach((entries) => {\n        entries.forEach((entry) => {\n          entry.processed = false;\n        });\n      });\n    });\n  }\n  hang_detect(current_op, resolution) {\n    if (current_op != this.hang_detect_op) {\n      this.hang_detect_op = current_op;\n      this.hang_detect_start = Date.now();\n      this.hang_detect_counter = 0;\n      this.hang_detect_resolution = resolution ? resolution : _WGSL_debug.HANG_DETECT_RESOLUTION;\n    } else {\n      this.hang_detect_counter++;\n      if (this.hang_detect_counter % this.hang_detect_resolution == 0) {\n        const now = Date.now();\n        if (now - this.hang_detect_start > _WGSL_debug.HANG_DETECT_LIMIT) {\n          console.warn(`WGSL_debug hang detected in '${current_op}' after ${this.hang_detect_counter} iterations (${_WGSL_debug.HANG_DETECT_LIMIT}ms), interrupting operation`);\n          this.hang_detect_op = null;\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n};\nlet WGSL_debug = _WGSL_debug;\nWGSL_debug.BUF_HEADER_SIZE = 16;\nWGSL_debug.BUF_HEADER_SIZE_BYTES = Uint32Array.BYTES_PER_ELEMENT * _WGSL_debug.BUF_HEADER_SIZE;\nWGSL_debug.BUF_UNIT_HEADER_SIZE = 1;\nWGSL_debug.BUF_UNIT_ENTRIES_COUNT_DEFAULT = 20;\nWGSL_debug.BUF_ENTRY_SIZE = 3;\nWGSL_debug.BUF_ENTRY_TYPE_U32 = 1;\nWGSL_debug.BUF_ENTRY_TYPE_I32 = 2;\nWGSL_debug.BUF_ENTRY_TYPE_F32 = 3;\nWGSL_debug.BUF_ENTRY_MARK_UNSET = 999999;\nWGSL_debug.HANG_DETECT_LIMIT = 500;\nWGSL_debug.HANG_DETECT_RESOLUTION = 100;\nWGSL_debug.SHADER_INACTIVE = `fn dbg_init(unit_id: u32) {}\n\nfn dbg_u32(val: u32) {}\nfn dbg_i32(val: i32) {}\nfn dbg_f32(val: f32) {}\nfn dbg_32(val: u32, vtype: u32) {}\n\nfn dbg_u32m(mark: i32, val: u32) {}\nfn dbg_i32m(mark: i32, val: i32) {}\nfn dbg_f32m(mark: i32, val: f32) {}\nfn dbg_32m(mark: i32, val: f32, vtype: i32) {}`;\nclass WGSL_debug_output {\n  constructor() {\n  }\n  attach(debug) {\n    console.log(\"WGSL_debug output attach\");\n    this.debug = debug;\n  }\n}\nconst _WGSL_debug_table = class extends WGSL_debug_output {\n  constructor(output_elm) {\n    super();\n    this.conf = {\n      selected_pass: 0,\n      pass_range: 0,\n      live: false,\n      dirty: false\n    };\n    const scroll_elm = output_elm + \"-scroll\";\n    const table_elm = output_elm + \"-table\";\n    const timeline_elm = output_elm + \"-timeline\";\n    const timelineval_elm = output_elm + \"-timelineval\";\n    const passcount_elm = output_elm + \"-passcount\";\n    const timelinelive_elm = output_elm + \"-timelinelive\";\n    const passrange_elm = output_elm + \"-passrange\";\n    const elm = document.getElementById(output_elm);\n    if (!elm) {\n      console.warn(`WGSL_debug: could not find debug output element id : '${output_elm}`);\n      return;\n    }\n    elm.innerHTML = `\n<div class=\"debug-output-controls\">\n\tpass&nbsp;&nbsp;\n\t<input type=\"number\" min=\"1\" max=\"0\" value=\"0\" step=\"1\" id=\"${timelineval_elm}\"/> &#xb1;\n\t<input type=\"number\" min=\"0\" max=\"60\" value=\"0\" step=\"1\" id=\"${passrange_elm}\"/> /\n\t<span id=\"${passcount_elm}\"></span>\n\t<input type=\"range\" min=\"1\" max=\"0\" value=\"0\" step=\"1\" id=\"${timeline_elm}\" class=\"debug-output-timeline\"/>\n\t<label><input type=\"checkbox\" checked=1 id=\"${timelinelive_elm}\" />live</label>\n</div>\n<div id=\"${scroll_elm}\" class=\"debug-output-table\">\n\t<table id=\"${table_elm}\">\n\t</table>\n<div>\n`;\n    this.scroll = document.getElementById(scroll_elm);\n    this.table = document.getElementById(table_elm);\n    this.timeline = document.getElementById(timeline_elm);\n    this.timelineval = document.getElementById(timelineval_elm);\n    this.passcount = document.getElementById(passcount_elm);\n    this.timelinelive = document.getElementById(timelinelive_elm);\n    this.passrange = document.getElementById(passrange_elm);\n    const table_scroll = (_) => {\n      this.update();\n    };\n    const timeline_input = (e) => {\n      this.conf.selected_pass = Number(e.target.value);\n      this.conf.live = false;\n      this.update();\n    };\n    const timelineval_input = (e) => {\n      this.conf.selected_pass = Number(e.target.value);\n      this.conf.live = false;\n      this.update();\n    };\n    const timelinelive_click = (e) => {\n      this.conf.live = e.target.checked;\n      this.update();\n    };\n    const passrange_input = (e) => {\n      this.conf.pass_range = Number(e.target.value);\n      this.row_height = 0;\n      this.debug.clear_processed();\n      this.reset();\n      this.update();\n    };\n    this.scroll.addEventListener(\"scroll\", table_scroll);\n    this.timeline.addEventListener(\"input\", timeline_input);\n    this.timelineval.addEventListener(\"input\", timelineval_input);\n    this.timelinelive.addEventListener(\"click\", timelinelive_click);\n    this.passrange.addEventListener(\"input\", passrange_input);\n    var style = document.createElement(\"style\");\n    style.innerHTML = `\n#${timelineval_elm} { width: 5em; }\n#${passrange_elm} { width: 3em; }\n`;\n    document.head.appendChild(style);\n    this.row_height = 0;\n    this.reset();\n  }\n  reset() {\n    if (!this.table) {\n      return;\n    }\n    this.col = new Array();\n    this.processed = new Array();\n    this.conf.selected_pass = 0;\n    this.conf.live = true;\n    this._reset_table();\n    this.update();\n  }\n  _reset_table() {\n    this.table.innerHTML = \"\";\n    var rowh = this.table.createTHead();\n    var cellh = document.createElement(\"th\");\n    cellh.innerText = `uid`;\n    rowh.appendChild(cellh);\n  }\n  update() {\n    if (!this.table || !this.debug) {\n      return;\n    }\n    while (this.processed.length < this.debug.record.length) {\n      this.processed.push(false);\n    }\n    if (window.getComputedStyle(this.table).visibility == \"hidden\") {\n      return;\n    }\n    const now = Date.now();\n    if (this.update_timeout || this.last_update && now - this.last_update < _WGSL_debug_table.MIN_UPDATE_INTERVAL) {\n      if (!this.update_timeout) {\n        this.update_timeout = setTimeout(() => {\n          this.update_timeout = null;\n          this.last_update = null;\n          this.update();\n        }, _WGSL_debug_table.MIN_UPDATE_INTERVAL);\n      }\n      return;\n    }\n    this.debug.hang_detect(\"reset\");\n    this.last_update = now;\n    const conf = this.conf;\n    const debug = this.debug;\n    const thead = this.table.tHead;\n    if (conf.live == true) {\n      conf.selected_pass = debug.pass_n;\n    }\n    this.timelineval.max = debug.pass_n.toString();\n    this.timelineval.value = conf.selected_pass.toString();\n    this.passcount.innerText = debug.pass_n.toString();\n    this.timeline.max = debug.pass_n.toString();\n    this.timeline.value = conf.selected_pass.toString();\n    this.timelinelive.checked = conf.live;\n    const pass = debug.record[conf.selected_pass - 1];\n    if (!pass) {\n      console.log(`table update no pass selected_pass=${conf.selected_pass} pass_n=${debug.pass_n} recordlen=${debug.record.length}`);\n      return;\n    }\n    if (this.table.rows.length < pass.length) {\n      console.log(`table update create_rows ${this.table.rows.length} to ${pass.length}`);\n      if (this.table.tBodies.length == 0) {\n        this.table.createTBody();\n      }\n      const celltext_empty = Array(1 + conf.pass_range * 2).fill(\"0\").join(\"<br/>\");\n      console.log(`table update create_rows celltext_empty=${celltext_empty}`);\n      var rows = \"\";\n      for (var n = this.table.rows.length; n < pass.length; n++) {\n        rows += \"<tr><th>\" + n.toString() + \"</th><td>\" + celltext_empty + \"</td></tr>\\n\";\n      }\n      this.table.tBodies[0].innerHTML += rows;\n      console.log(`table update create_rows trigger`);\n      this.table.rows[0].cells[1].innerHTML = celltext_empty;\n      console.log(`table update create_rows done`);\n    }\n    if (!this.row_height) {\n      console.log(\"table update get first cell\");\n      const firstcell = this.table.rows[0].cells[1];\n      console.log(\"table update get first cell style\");\n      const style = window.getComputedStyle(firstcell);\n      console.log(\"table update calculate row_height\");\n      this.row_height = Number(style.height.replace(\"px\", \"\")) + Number(style.paddingTop.replace(\"px\", \"\")) + Number(style.paddingBottom.replace(\"px\", \"\"));\n      console.log(`WGSL_debug_table setting row_height=${this.row_height}`);\n    }\n    const scrolltop = this.scroll.scrollTop;\n    const table_y_visible = [\n      scrolltop,\n      scrolltop + this.scroll.clientHeight\n    ];\n    const row_visible = [\n      Math.floor(table_y_visible[0] / this.row_height),\n      Math.min(Math.ceil(table_y_visible[1] / this.row_height) + 1, pass.length)\n    ];\n    if (!this.processed[this.conf.selected_pass - 1]) {\n      pass.every((entries) => {\n        if (this.debug.hang_detect(\"table update process_pass\")) {\n          return false;\n        }\n        var col_n2 = 0;\n        entries.forEach((entry) => {\n          if (entry.processed) {\n            return;\n          }\n          var len = entry.value.toString().length + _WGSL_debug_table.COL_WIDTH_ADJUST;\n          if (this.conf.pass_range > 0) {\n            len += 2;\n          }\n          for (var col_ins = col_n2; ; col_ins++) {\n            if (col_ins == this.col.length) {\n              var cellh = document.createElement(\"th\");\n              if (entry.mark != WGSL_debug.BUF_ENTRY_MARK_UNSET) {\n                if (debug.marks[entry.mark]) {\n                  cellh.innerText = debug.marks[entry.mark];\n                } else {\n                  cellh.innerText = entry.mark.toString();\n                }\n              } else {\n                cellh.innerText = \"d\" + col_n2.toString();\n              }\n              thead.insertBefore(cellh, thead.children[col_n2].nextSibling);\n              const col = {\n                maxlen: len,\n                mark: entry.mark,\n                dirty_maxlen: true,\n                width: 0\n              };\n              this.col.splice(col_n2, 0, col);\n              break;\n            }\n            if (this.col[col_ins].mark == entry.mark) {\n              col_n2 = col_ins;\n              break;\n            }\n          }\n          if (len > this.col[col_n2].maxlen) {\n            this.col[col_n2].maxlen = len;\n            this.col[col_n2].dirty_maxlen = true;\n          }\n          col_n2++;\n          entry.processed = true;\n        });\n        return true;\n      });\n      this.processed[this.conf.selected_pass - 1] = true;\n    }\n    const table_x_visible = [\n      this.scroll.scrollLeft,\n      this.scroll.scrollLeft + this.scroll.clientWidth\n    ];\n    var col_offsetx = 0;\n    var col_visible = [0, this.col.length];\n    this.col.every((col, col_n2) => {\n      if (this.debug.hang_detect(\"table update header columns\", 1)) {\n        return false;\n      }\n      if (col_offsetx < table_x_visible[0]) {\n        col_visible[0] = col_n2;\n      }\n      if (col.dirty_maxlen) {\n        const cellh = thead.children[col_n2 + 1];\n        const s2 = `min-width: ${col.maxlen}ex;`;\n        cellh.setAttribute(\"style\", s2);\n        const style = window.getComputedStyle(cellh);\n        col.width = Number(style.width.replace(\"px\", \"\"));\n      }\n      col_offsetx += col.width;\n      if (col_offsetx < table_x_visible[1]) {\n        col_visible[1] = col_n2 + 1;\n      }\n      return true;\n    });\n    for (var uid = row_visible[0]; uid < row_visible[1]; uid++) {\n      if (this.debug.hang_detect(\"table update content\")) {\n        break;\n      }\n      const entries = pass[uid];\n      const row = this.table.rows[uid];\n      var col_n = 0;\n      for (var entry_n = col_visible[0]; entry_n < col_visible[1]; entry_n++) {\n        const entry = entries[entry_n];\n        if (!entry) {\n          continue;\n        }\n        while (entry.mark != this.col[col_n].mark) {\n          col_n++;\n          if (col_n == this.col.length) {\n            console.warn(`WGSL_debug update html table content: did not find column mark for entry at uid=${uid} entry_n=${entry_n}`);\n            return;\n          }\n        }\n        while (!row.cells[col_n + 1]) {\n          row.insertCell(-1);\n        }\n        const cell = row.cells[col_n + 1];\n        var s = \"\";\n        if (conf.pass_range == 0) {\n          s = entry.value.toString();\n        } else {\n          const ctx_center = Math.max(conf.pass_range, Math.min(conf.selected_pass - 1, debug.record.length - 1 - conf.pass_range));\n          const ctx_first = ctx_center - conf.pass_range;\n          const ctx_last = ctx_center + conf.pass_range;\n          for (var ctx_n = ctx_first; ctx_n <= ctx_last; ctx_n++) {\n            if (ctx_n == conf.selected_pass - 1) {\n              s += \"*\" + entry.value + \"*\";\n            } else {\n              const ctx_pass = debug.record[ctx_n];\n              s += ctx_pass && entry_n < ctx_pass[uid].length ? ctx_pass[uid][entry_n].value : \"-\";\n            }\n            if (ctx_n < ctx_last) {\n              s += \"\\n\";\n            }\n          }\n        }\n        cell.innerText = s;\n        col_n++;\n      }\n    }\n  }\n};\nlet WGSL_debug_table = _WGSL_debug_table;\nWGSL_debug_table.COL_WIDTH_ADJUST = 3;\nWGSL_debug_table.MIN_UPDATE_INTERVAL = 100;\nexport { WGSL_debug_table };\n//# sourceMappingURL=wgsl-debug-table.es.js.map\n","import { WGSL_debug } from 'wgsl-debug'\nimport { WGSL_debug_table } from 'wgsl-debug-table'\n\nconst VALUES_COUNT = 1000 * 1000\nconst BUF_UNIFORMS_SIZE = 1 + 1 // values_count + time\nconst BUF_UNIFORMS_SIZE_BYTES = BUF_UNIFORMS_SIZE * Uint32Array.BYTES_PER_ELEMENT;\nconst BUF_VALUES_SIZE = VALUES_COUNT * 2; // f32 * 2\nconst BUF_VALUES_SIZE_BYTES = BUF_VALUES_SIZE * Float32Array.BYTES_PER_ELEMENT;\nconst WORKGROUP_SIZE = 256;\nconst WORKGROUP_COUNT = 5;\nconst BINDGROUP_VALUES_NUM = 0;\nconst BINDGROUP_DEBUG_NUM = 1;\nconst PASS_MAX = 3000;\nconst DEBUG_ENTRIES_MAX = 4;\n\nconst SHADER_SRC = `struct uniform_t {\n\tvalues_count: u32;\n\ttime: f32;\n};\n\n@group(0) @binding(0) var<uniform> uniforms: uniform_t;\n@group(0) @binding(1) var<storage,read_write> c_values: array<vec2<f32>>;\n@stage(compute) @workgroup_size(#WORKGROUP_SIZE)\nfn compute(@builtin(local_invocation_id) lid: vec3<u32>,\n\t   @builtin(workgroup_id) wid: vec3<u32>,\n\t   @builtin(num_workgroups) numw: vec3<u32>) {\n\tvar i = wid.x * #WORKGROUP_SIZEu + lid.x;\n\tfor (; i < uniforms.values_count; i = i + #WORKGROUP_SIZEu * numw.x) {\n\t\tdbg_init(i);\n\t\tvar v = c_values[i];\n\t\tdbg_f32m(0, v.x);\t\t    // x\n\t\tdbg_f32m(1, v.y);\t\t    // y\n\t\tdbg_f32m(2, uniforms.time);\t    // time\n\t\tv = v * (1.0 + sin(uniforms.time / 1000.0) * 0.1);\n\t\tc_values[i] = v;\n\t}\n}\n\n@group(0) @binding(0) var<storage,read> v_values: array<vec2<f32>>;\n@stage(vertex)\nfn vertex(@builtin(vertex_index) vidx: u32) -> @builtin(position) vec4<f32> {\n        var v = v_values[vidx];\n        return vec4(v, 0.0, 1.0);\n}\n\n@stage(fragment)\nfn fragment() -> @location(0) vec4<f32> {\n        return vec4(1.0, 0.0, 0.0, 1.0);\n}`.replace(/#WORKGROUP_SIZE/g, WORKGROUP_SIZE.toString());\n\nvar _device: GPUDevice;\nvar _cbindgroup: GPUBindGroup;\nvar _cpipeline: GPUComputePipeline;\nvar _rbindgroup: GPUBindGroup;\nvar _rpipeline: GPURenderPipeline;\nvar _debug: WGSL_debug;\nvar _debug_table: WGSL_debug_table;\nvar _context: GPUCanvasContext;\nvar _buf_uniforms: GPUBuffer;\nvar _buf_values: GPUBuffer;\nvar _presentation_format: GPUTextureFormat;\nvar _need_setup: boolean;\nvar _pass_n = 0;\nvar _compute_active = true;\nvar _debug_active = true;\nvar _stats: HTMLElement | null;\nvar _debug_uidmax = 2000;\n\nasync function main() {\n\t/* prepare WebGPU device and context */\n\tconst gpu = navigator.gpu;\n\tif (!gpu) {\n\t\terr(\"your browser does not seem to support WebGPU\");\n\t}\n\tvar adapter = await gpu.requestAdapter();\n\tif (!adapter) {\n\t\terr(\"request for GPU adapter failed\");\n\t}\n\t_device = await adapter.requestDevice();\n\tvar canvas = <HTMLCanvasElement>document.getElementById(\"canvas\");\n\t_context = canvas.getContext(\"webgpu\");\n\tif (!_context) {\n\t\terr(\"could not get WebGPU context\");\n\t}\n\tconst pixelratio = window.devicePixelRatio || 1;\n\tconst size = [canvas.clientWidth, canvas.clientHeight];\n\tconst presentation_size = [ size[0] * pixelratio, size[1] * pixelratio ];\n\t_presentation_format = _context.getPreferredFormat(adapter);\n\t_context.configure({ device: _device, format: _presentation_format, size: presentation_size });\n\tdocument.getElementById(\"shader_src\").innerHTML = SHADER_SRC.replace(/dbg/g, \"<mark>dbg</mark>\");\n\t_stats = document.getElementById(\"stats\");\n\n\t/* create uniforms and values buffer */\n\t_buf_uniforms = _device.createBuffer({\n\t\tsize: BUF_UNIFORMS_SIZE_BYTES,\n\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n\t})\n\t_buf_values = _device.createBuffer({\n\t\tsize: BUF_VALUES_SIZE_BYTES,\n\t\tusage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX,\n\t\tmappedAtCreation: true });\n\tconst values = new Float32Array(_buf_values.getMappedRange());\n\tconst pos_angle = 2.0 * Math.PI / VALUES_COUNT;\n\tfor (var n=0; n < VALUES_COUNT; n++) {\n\t\tvalues[n*2 + 0] = 0.5 * Math.cos(n * pos_angle);\n\t\tvalues[n*2 + 1] = 0.5 * Math.sin(n * pos_angle);\n\t}\n\t_buf_values.unmap();\n\n\t/* wgsl-debug: create debug instance */\n\t_debug = new WGSL_debug(BINDGROUP_DEBUG_NUM, DEBUG_ENTRIES_MAX);\n\t_debug_table = new WGSL_debug_table(\"debug-div\");\n\t_debug.set_output(_debug_table);\n\n\t_need_setup = true;\n\n\twindow.requestAnimationFrame(frame);\n}\n\nasync function setup() {\n\tconsole.log(`setup debug_active=${_debug_active}`);\n\t/* wgsl-debug: add debug shader to shader_src */\n\tconst shader_src = _debug.add_shader(SHADER_SRC, _debug_active);\n\n\t/* create shaders and pipelines */\n\tconst shader = _device.createShaderModule({ code: shader_src });\n        const infos = await shader.compilationInfo();\n        if (infos.messages.length > 0) {\n                err(`shader compilation has failed:\\n` + infos.messages.map(m => `${m.lineNum}:${m.linePos} [${m.type}] ${m.message}`) );\n        }\n\t_cpipeline = _device.createComputePipeline({\n\t\tcompute: { module: shader, entryPoint: 'compute' } });\n\t_rpipeline = _device.createRenderPipeline({\n\t\tvertex: { module: shader, entryPoint: 'vertex', },\n\t\tfragment: { module: shader, entryPoint: 'fragment',\n\t\t\t    targets: [{ format: _presentation_format, }], },\n\t\tprimitive: { topology: 'point-list', },\n\t});\n\n\t/* create bind groups */\n\t_cbindgroup = _device.createBindGroup({\n\t\tlayout: _cpipeline.getBindGroupLayout(BINDGROUP_VALUES_NUM),\n\t\tentries: [\n\t\t\t{ binding: 0, resource: {buffer: _buf_uniforms} },\n\t\t\t{ binding: 1, resource: {buffer: _buf_values} },\n\t\t],\n\t});\n\t_rbindgroup = _device.createBindGroup({\n\t\tlayout: _rpipeline.getBindGroupLayout(BINDGROUP_VALUES_NUM),\n\t\tentries: [ { binding: 0, resource: {buffer: _buf_values}} ],\n\t});\n\n\t/* wgsl-debug: create buffers and bindgroups */\n\tif (_debug_active) {\n\t\t_debug.setup(_device, _debug_uidmax);\n\t\t_debug.create_bindgroup(_cpipeline);\n\t}\n\n\t_need_setup = false;\n}\n\nasync function frame() {\n\tif (_need_setup) {\n\t\tawait setup();\n\t}\n\n\tif (_pass_n == 0 || _pass_n % 20 == 0) {\n\t\t_stats.innerText = `Points count: ${VALUES_COUNT}\nDispatch count: ${WORKGROUP_COUNT}\nCompute pass: ${_pass_n}`;\n\t}\n\n\tconst cmd = _device.createCommandEncoder();\n\tconst time = performance.now();\n\n\t/* update uniforms */\n\tconst uniforms = new ArrayBuffer(BUF_UNIFORMS_SIZE_BYTES);\n\tnew Uint32Array(uniforms, 0, 1).set([VALUES_COUNT]);\n\tnew Float32Array(uniforms, 4, 1).set([time]);\n\t_device.queue.writeBuffer(_buf_uniforms, 0, uniforms);\n\n\t/* compute pass */\n\tif (_compute_active) {\n\t\tconst cpass = cmd.beginComputePass();\n\t\tcpass.setPipeline(_cpipeline);\n\t\tcpass.setBindGroup(0, _cbindgroup);\n\t\tif (_debug_active) {\n\t\t\t_debug.set_bindgroup(cpass); /* wgsl-debug: set debug bindgroup */\n\t\t}\n\t\tcpass.dispatch(WORKGROUP_COUNT);\n\t\tcpass.end();\n\t\t_pass_n++;\n\t}\n\n\t/* render pass */\n\tconst texture_view = _context.getCurrentTexture().createView();\n\tconst render_pass_descriptor: GPURenderPassDescriptor = {\n\t\tcolorAttachments: [{\n\t\t\tview: texture_view,\n\t\t\tclearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n\t\t\tloadOp: 'clear',\n\t\t\tstoreOp: 'store',\n\t\t}]\n\t};\n\tconst rpass = cmd.beginRenderPass(render_pass_descriptor);\n\trpass.setPipeline(_rpipeline);\n\trpass.setBindGroup(0, _rbindgroup);\n\trpass.draw(VALUES_COUNT, 1, 0, 0);\n\trpass.end();\n\n\t/* wgsl-debug: fetch debug data */\n\tif (_debug_active) {\n\t\t_debug.fetch(cmd);\n\t}\n\n\t/* submit command buffer */\n\tconst cmd_buffer = cmd.finish();\n\t_device.queue.submit([cmd_buffer]);\n\n\t/* wgsl-debug: process debug data */\n\tif (_debug_active) {\n\t\tawait _debug.process();\n\t}\n\t\n\tif (_pass_n <= PASS_MAX) {\n\t\twindow.requestAnimationFrame(frame);\n\t} else {\n\t\t_stats.innerText = _stats.innerText + \"\\nPASS_MAX reached\";\n\t\t(document.getElementById(\"compute_active\") as HTMLInputElement).checked = false;\n\t}\n}\n\nfunction cb_compute_active(e: Event) {\n\tconst elm = (e.target as HTMLInputElement);\n\t_compute_active = elm.checked;\n}\n\nfunction cb_debug_active(e: Event) {\n\tconst elm = (e.target as HTMLInputElement);\n\t_debug_active = elm.checked;\n\t_need_setup = true;\n}\n\nfunction cb_debug_visible() {\n\tconst elm = document.getElementById(\"debug-div\");\n\telm.classList.toggle(\"hidden\");\n}\n\nfunction cb_debug_uidmax_set() {\n\tconst elm = document.getElementById(\"debug_uidmax\") as HTMLInputElement;\n\t_debug_uidmax = Number(elm.value);\n\t_need_setup = true;\n}\n\nfunction err(msg: string) {\n\talert(msg);\n\tthrow new Error(msg);\n}\n\ndocument.addEventListener('DOMContentLoaded', main);\ndocument.getElementById(\"compute_active\").addEventListener('click', cb_compute_active);\ndocument.getElementById(\"debug_active\").addEventListener('click', cb_debug_active);\ndocument.getElementById(\"debug_visible\").addEventListener('click', cb_debug_visible);\ndocument.getElementById(\"debug_uidmax_set\").addEventListener('click', cb_debug_uidmax_set);\n(document.getElementById(\"debug_uidmax\") as HTMLInputElement).value = _debug_uidmax.toString();\n(document.getElementById(\"debug_uidmax\") as HTMLInputElement).max = VALUES_COUNT.toString();\n"],"names":["_WGSL_debug","WGSL_debug"],"mappings":"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"}